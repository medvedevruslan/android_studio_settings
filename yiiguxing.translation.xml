<application>
  <component name="AppStorage">
    <histories>
      <item value="Activity for scanning and displaying available Bluetooth LE devices." />
      <item value="Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License." />
      <item value="Unless" />
      <item value="This device has no Bluetooth hardware" />
      <item value="check Permissions" />
      <item value="REQUEST ENABLE" />
      <item value="android.bluetooth.adapter.action.REQUEST ENABLE&quot;" />
      <item value="is Bluetooth Enabled" />
      <item value="glucose Data Receiver" />
      <item value="weight Data Receiver" />
      <item value="pulse Ox Data Receiver" />
      <item value="heart Rate Data Receiver" />
      <item value="temperature Data Receiver" />
      <item value="location Service State Receiver" />
      <item value="blood Pressure Data Receiver" />
      <item value="Location Manager" />
      <item value="MODE CHANGED ACTION" />
      <item value="register Receiver" />
      <item value="registerReceiver(locationServiceStateReceiver, new IntentFilter((LocationManager.MODE_CHANGED_ACTION))); registerReceiver(bloodPressureDataReceiver, new IntentFilter( BluetoothHandler.MEASUREMENT_BLOODPRESSURE )); registerReceiver(temperatureDataReceiver, new IntentFilter( BluetoothHandler.MEASUREMENT_TEMPERATURE )); registerReceiver(heartRateDataReceiver, new IntentFilter( BluetoothHandler.MEASUREMENT_HEARTRATE )); registerReceiver(pulseOxDataReceiver, new IntentFilter( BluetoothHandler.MEASUREMENT_PULSE_OX )); registerReceiver(weightDataReceiver, new IntentFilter(BluetoothHandler.MEASUREMENT_WEIGHT)); registerReceiver(glucoseDataReceiver, new IntentFilter(BluetoothHandler.MEASUREMENT_GLUCOSE));" />
      <item value="blood Pressure Value" />
      <item value="REQUEST ENABLE BT" />
      <item value="ACCESS LOCATION REQUEST" />
      <item value="This class includes a small subset of standard GATT attributes for demonstration purposes." />
      <item value="Use this check to determine whether BLE is supported on the device. Then you can selectively disable BLE-related features." />
      <item value="Ensures Bluetooth is enabled on the device. If Bluetooth is not currently enabled, fire an intent to display a dialog asking the user to grant permission to enable it. if (!mBluetoothAdapter.isEnabled()) {" />
      <item value="Initializes a Bluetooth adapter. For API level 18 and above, get a reference to BluetoothAdapter through BluetoothManager." />
      <item value="Device scan callback." />
      <item value="Stops scanning after a pre-defined scan period." />
      <item value="actionbar indeterminate progress" />
      <item value="set Action View" />
      <item value="Ensures Bluetooth is enabled on the device. If Bluetooth is not currently enabled, fire an intent to display a dialog asking the user to grant permission to enable it." />
      <item value="access modifiers changed from: private" />
      <item value="Use this check to determine whether BLE is supported on the device. Then you can selectively disable BLE-related features" />
      <item value="A {@code Method} provides information about, and access to, a single method on a class or interface. The reflected method may be a class method or an instance method (including an abstract method). &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the actual parameters to invoke with the underlying method's formal parameters, but it throws an {@code IllegalArgumentException} if a narrowing conversion would occur." />
      <item value="Discovered LE Device" />
      <item value="No Application available to view File" />
      <item value="java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity." />
      <item value="exist" />
      <item value="NOTE: Do not place your application dependencies here; they belong in the individual module build.gradle files" />
      <item value="Top-level build file where you can add configuration options common to all sub-projectsmodules." />
      <item value="Manifest merger failed with multiple errors, see logs" />
      <item value="Crypt" />
      <item value="External storage is not available" />
      <item value="External storage is not writable" />
      <item value="mounted" />
      <item value="@param type The type of files directory to return. May be {@code null} for the root of the files directory or one of the following constants for a subdirectory: {@link android.os.EnvironmentDIRECTORY_MUSIC}, {@link android.os.EnvironmentDIRECTORY_PODCASTS}, {@link android.os.EnvironmentDIRECTORY_RINGTONES}, {@link android.os.EnvironmentDIRECTORY_ALARMS}, {@link android.os.EnvironmentDIRECTORY_NOTIFICATIONS}, {@link android.os.EnvironmentDIRECTORY_PICTURES}, or {@link android.os.EnvironmentDIRECTORY_MOVIES}. @return the absolute path to application-specific directory. May return" />
      <item value="Returns the absolute path to the directory on the primary sharedexternal storage device where the application can place persistent files it owns. These files are internal to the applications, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding {@link android.Manifest.permissionWRITE_EXTERNAL_STORAGE} can write to these files. &lt;ul&gt; &lt;p&gt; If a shared storage device is emulated (as determined by {@link EnvironmentisExternalStorageEmulated(File)}), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by {@link getFilesDir()}, etc. &lt;p&gt; Starting in {@link android.os.Build.VERSION_CODESKITKAT}, no permissions are required to read or write to the returned path; it's always accessible to the calling app. This only applies to paths generate" />
      <item value="Returns the absolute path to the directory on the primary sharedexternal storage device where the application can place persistent files it owns. These files are internal to the applications, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding" />
      <item value="Returns absolute paths to application-specific directories on all sharedexternal storage devices where the application can place persistent files it owns. These files are internal to the application, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding {@link android.Manifest.permissionWRITE_EXTERNAL_STORAGE} can write to these files. &lt;ul&gt; &lt;p&gt; If a shared storage device is emulated (as determined by {@link EnvironmentisExternalStorageEmulated(File)}), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by {@link getFilesDir()}, etc." />
      <item value="Builder" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="123" />
        <entry key="RUSSIAN" value="122" />
        <entry key="GALICIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1617253699672" />
  </component>
</application>