<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="2027" />
    <option name="newTranslationDialogX" value="720" />
    <option name="newTranslationDialogY" value="955" />
    <histories>
      <item value="Retrieve the {@link OnBackPressedDispatcher} that will be triggered when {@link onBackPressed()} is called. @return The {@link OnBackPressedDispatcher} associated with this ComponentActivity." />
      <item value="Retrieve the {@link OnBackPressedDispatcher} that will be triggered when {@link onBackPressed()} is called. @return The {@link OnBackPressedDispatcher} associated with this ComponentActivity" />
      <item value="on Back Pressed Dispatcher" />
      <item value="Not Paired" />
      <item value="Laments" />
      <item value="Sets whether this dialog is canceled when touched outside the window's bounds. If setting to true, the dialog is set to be cancelable if not already set." />
      <item value="set Canceled On Touch Outside" />
      <item value="Dialog Modes" />
      <item value="handle On Back Pressed" />
      <item value="Preferences" />
      <item value="Preferences Methods Fragment" />
      <item value="scale Type" />
      <item value="process Stream" />
      <item value="resolve" />
      <item value="Response Error" />
      <item value="handle Result" />
      <item value="is Valid" />
      <item value="Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception)." />
      <item value="Returns a string representation of the object." />
      <item value="ndicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements: Reflexive: for any non-null value x, x.equals(x) should return true. Symmetric: for any non-null values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. Transitive: for any non-null values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. Consistent: for any non-null values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. Never equal to null: for any non-null value x, x.equals(null) should return fals" />
      <item value="The root of the Kotlin class hierarchy. Every Kotlin class has Any as a superclass." />
      <item value="Receiver's interface to Channel." />
      <item value="state" />
      <item value="state Block" />
      <item value="Failure" />
      <item value="end region" />
      <item value="endregion" />
      <item value="By overriding invoke, we allow use cases to be called as &quot;invoking&quot;" />
      <item value="invoke" />
      <item value="region" />
      <item value="region Functions" />
      <item value="Get person from persistence and send it, synchronous" />
      <item value="If a list is already being displayed, a diff will be computed on a background thread, which will dispatch Adapter.notifyItem events on the main thread." />
      <item value="Submits a new list to be diffed, and displayed." />
      <item value="Submits a new list to be diffed, and displayed. &lt;p&gt; If a list is already being displayed, a diff will be computed on a background thread, which will dispatch Adapter.notifyItem events on the main thread. @param list The new list to be displayed." />
      <item value="child Count" />
      <item value="The total number of items in the dataset after the last load" />
      <item value="Add a listener that will be notified of any changes in scroll state or position. Components that add a listener should take care to remove it when finished. Other components that take ownership of a view may call clearOnScrollListeners() to remove all attached listeners" />
      <item value="add On Scroll Listener" />
      <item value="receive Channel" />
      <item value="handle Success" />
      <item value="fade Animation" />
      <item value="clear On Scroll Listeners" />
      <item value="Evaluates the pending bindings, updating any Views that have expressions bound to modified variables. This &lt;b&gt;must&lt;b&gt; be run on the UI thread." />
      <item value="Cannot resolve type 'recyclerViewModel'" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance. &lt;p&gt; &lt;b&gt;Example&lt;b&gt; &lt;pre&gt; final class MyDetailsLookup extends ItemDetailsLookup&lt;Uri&gt; { private final RecyclerView mRecyclerView; MyDetailsLookup(RecyclerView recyclerView) { mRecyclerView = recyclerView; } public @Nullable ItemDetails&lt;Uri&gt; getItemDetails(@NonNull MotionEvent e) { View view = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (view != null) { ViewHolder holder = mRecyclerView.getChildViewHolder(view); if (holder instanceof MyHolder) { return ((MyHolder) holder).getItemDetails(); } } return null;" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance." />
      <item value="Item Details Lookup" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance. &lt;p&gt; &lt;b&gt;Example&lt;b&gt; &lt;pre&gt; final class MyDetailsLookup extends ItemDetailsLookup&lt;Uri&gt; { private final RecyclerView mRecyclerView; MyDetailsLookup(RecyclerView recyclerView) { mRecyclerView = recyclerView; } public @Nullable ItemDetails&lt;Uri&gt; getItemDetails(@NonNull MotionEvent e) { View view = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (view != null) { ViewHolder holder = mRecyclerView.getChildViewHolder(view); if (holder instanceof MyHolder) { return ((MyHolder) holder).getItemDetails(); } } return null; } }" />
      <item value="save Complaints" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="856" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="856" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1649652957837" />
  </component>
</application>