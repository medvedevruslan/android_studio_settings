<application>
  <component name="AppStorage">
    <histories>
      <item value="Use this check to determine whether BLE is supported on the device. Then you can selectively disable BLE-related features." />
      <item value="Activity for scanning and displaying available Bluetooth LE devices." />
      <item value="Ensures Bluetooth is enabled on the device. If Bluetooth is not currently enabled, fire an intent to display a dialog asking the user to grant permission to enable it. if (!mBluetoothAdapter.isEnabled()) {" />
      <item value="Initializes a Bluetooth adapter. For API level 18 and above, get a reference to BluetoothAdapter through BluetoothManager." />
      <item value="Device scan callback." />
      <item value="Stops scanning after a pre-defined scan period." />
      <item value="actionbar indeterminate progress" />
      <item value="set Action View" />
      <item value="Ensures Bluetooth is enabled on the device. If Bluetooth is not currently enabled, fire an intent to display a dialog asking the user to grant permission to enable it." />
      <item value="access modifiers changed from: private" />
      <item value="Use this check to determine whether BLE is supported on the device. Then you can selectively disable BLE-related features" />
      <item value="This class includes a small subset of standard GATT attributes for demonstration purposes." />
      <item value="A {@code Method} provides information about, and access to, a single method on a class or interface. The reflected method may be a class method or an instance method (including an abstract method). &lt;p&gt;A {@code Method} permits widening conversions to occur when matching the actual parameters to invoke with the underlying method's formal parameters, but it throws an {@code IllegalArgumentException} if a narrowing conversion would occur." />
      <item value="Discovered LE Device" />
      <item value="No Application available to view File" />
      <item value="java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity." />
      <item value="exist" />
      <item value="NOTE: Do not place your application dependencies here; they belong in the individual module build.gradle files" />
      <item value="Top-level build file where you can add configuration options common to all sub-projectsmodules." />
      <item value="Manifest merger failed with multiple errors, see logs" />
      <item value="Crypt" />
      <item value="External storage is not available" />
      <item value="External storage is not writable" />
      <item value="mounted" />
      <item value="@param type The type of files directory to return. May be {@code null} for the root of the files directory or one of the following constants for a subdirectory: {@link android.os.EnvironmentDIRECTORY_MUSIC}, {@link android.os.EnvironmentDIRECTORY_PODCASTS}, {@link android.os.EnvironmentDIRECTORY_RINGTONES}, {@link android.os.EnvironmentDIRECTORY_ALARMS}, {@link android.os.EnvironmentDIRECTORY_NOTIFICATIONS}, {@link android.os.EnvironmentDIRECTORY_PICTURES}, or {@link android.os.EnvironmentDIRECTORY_MOVIES}. @return the absolute path to application-specific directory. May return" />
      <item value="Returns the absolute path to the directory on the primary sharedexternal storage device where the application can place persistent files it owns. These files are internal to the applications, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding {@link android.Manifest.permissionWRITE_EXTERNAL_STORAGE} can write to these files. &lt;ul&gt; &lt;p&gt; If a shared storage device is emulated (as determined by {@link EnvironmentisExternalStorageEmulated(File)}), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by {@link getFilesDir()}, etc. &lt;p&gt; Starting in {@link android.os.Build.VERSION_CODESKITKAT}, no permissions are required to read or write to the returned path; it's always accessible to the calling app. This only applies to paths generate" />
      <item value="Returns the absolute path to the directory on the primary sharedexternal storage device where the application can place persistent files it owns. These files are internal to the applications, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding" />
      <item value="Returns absolute paths to application-specific directories on all sharedexternal storage devices where the application can place persistent files it owns. These files are internal to the application, and not typically visible to the user as media. &lt;p&gt; This is like {@link getFilesDir()} in that these files will be deleted when the application is uninstalled, however there are some important differences: &lt;ul&gt; &lt;li&gt;Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using {@link EnvironmentgetExternalStorageState(File)}. &lt;li&gt;There is no security enforced with these files. For example, any application holding {@link android.Manifest.permissionWRITE_EXTERNAL_STORAGE} can write to these files. &lt;ul&gt; &lt;p&gt; If a shared storage device is emulated (as determined by {@link EnvironmentisExternalStorageEmulated(File)}), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by {@link getFilesDir()}, etc." />
      <item value="Builder" />
      <item value="Storage" />
      <item value="KEY LAST UPDATED TIME STRING" />
      <item value="FASTEST UPDATE INTERVAL IN MILLISECONDS" />
      <item value="CREATE TABLE IF NOT EXISTS" />
      <item value="TABLE IF NOT EXISTS" />
      <item value="IF NOT EXISTS" />
      <item value="table &quot;tables&quot; has more than one primary key" />
      <item value="(OS error - 2:No such file or directory)" />
      <item value="able &quot;tables&quot; has more than one primary key" />
      <item value="android.database.sqlite.SQLiteException: table &quot;tables&quot; has more than one primary key (Sqlite code 1 SQLITE_ERROR): , while compiling: CREATE TABLE IF NOT EXISTS tables(_id INTEGER PRIMARY KEY,title TEXT, specification TEXT, price INTEGER PRIMARY KEY, weight FLOAT), (OS error - 2:No such file or directory)" />
      <item value="Please, commit your changes before you merge." />
      <item value="You have not concluded your merge (MERGE_HEAD exists)." />
      <item value="Please correct the file content" />
      <item value="Load Settings Cannot load settings from file 'homeruslanДокументыAndroidStudioProjects2021.03Breathalyzer.ideamodulesBreathalyzer.iml': File homeruslanДокументыAndroidStudioProjects2021.03Breathalyzer.ideamodulesBreathalyzer.iml does not exist Please correct the file content" />
      <item value="How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered." />
      <item value="FLAVOR" />
      <item value="android:input Type=&quot;text Cap Words&quot;" />
      <item value="11:31 Reset Failed: Cannot do a keep reset in the middle of a merge. (show balloon)" />
      <item value="Unresolved conflicts remaining in the project.Then you may continue rebase. You also may abort rebase to restore the original branch and stop rebasing." />
      <item value="Can't continue rebase Unresolved conflicts remaining in the project.Then you may continue rebase. You also may abort rebase to restore the original branch and stop rebasing." />
      <item value="10:24 Can't merge because of unmerged files" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="92" />
        <entry key="RUSSIAN" value="91" />
        <entry key="GALICIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1616397162755" />
  </component>
</application>