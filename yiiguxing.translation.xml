<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="1995" />
    <option name="newTranslationDialogX" value="5005" />
    <option name="newTranslationDialogY" value="1307" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="TODO(&quot;Not yet implemented&quot;)" />
      <item value="Creates a supervisor job object in an active state. Children of a supervisor job can fail independently of each other. A failure or cancellation of a child does not cause the supervisor job to fail and does not affect its other children, so a supervisor can implement a custom policy for handling failures of its children:" />
      <item value="This method will be called when this ViewModel is no longer used and will be destroyed. It is useful when ViewModel observes some data and you need to clear this subscription to prevent a leak of this ViewModel." />
      <item value="Returns a List containing all elements. The operation is terminal. This function consumes all elements of the original ReceiveChannel." />
      <item value="violate" />
      <item value="Receiver's interface to Channel." />
      <item value="error: TitleDao_Impl is not abstract and does not override abstract method insertTitle(Title,Continuation&lt;? super Unit&gt;) in TitleDao public final class TitleDao_Impl implements TitleDao { ^" />
      <item value="Refresh the title, showing a loading spinner while it refreshes and errors via snackbar." />
      <item value="completable.await()`" />
      <item value="insert Title" />
      <item value="Dao" />
      <item value="Unable to refresh title" />
      <item value="on" />
      <item value="on Completed" />
      <item value="A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task." />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion" />
      <item value="finally" />
      <item value="Called immediately after the UI shows the snackbar." />
      <item value="cause the original cause of this exception" />
      <item value="cause" />
      <item value="Title Refresh Callback" />
      <item value="Annotates fields that reference rules or methods that return a rule. A field must be public, not static, and a subtype of org.junit.rules.TestRule (preferred) or org.junit.rules.MethodRule. A method must be public, not static, and must return a subtype of org.junit.rules.TestRule (preferred) or org.junit.rules.MethodRule. The org.junit.runners.model.Statement passed to the org.junit.rules.TestRule will run any Before methods, then the Test method, and finally any After methods, throwing an exception if any of these fail. If there are multiple annotated Rules on a class, they will be applied in order of methods first, then fields. However, if there are multiple fields (or methods) they will be applied in an order that depends on your JVM's implementation of the reflection API, which is undefined, in general. Rules defined by fields will always be applied after Rules defined by methods, i.e. the Statements returned by the former will be executed around those returned by the latter." />
      <item value="A JUnit Test Rule that swaps the background executor used by the Architecture Components with a different one which executes each task synchronously. You can use this rule for your host side tests that use Architecture Components." />
      <item value="Before" />
      <item value="subject" />
      <item value="instant Task Executor Rule" />
      <item value="instant" />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion." />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion. Params: task – the task to submit" />
      <item value="An executor service that can run [Runnable]s off the main thread." />
      <item value="Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown. Params: nThreads – the number of threads in the pool Returns: the newly created thread pool Throws: IllegalArgumentException – if nThreads &lt;= 0" />
      <item value="Executors" />
      <item value="_spinner" />
      <item value="Could not determine the dependencies of task ':start:compileDebugJavaWithJavac'. &gt; Cannot query the value of property 'bootClasspath' because it has no value available." />
      <item value="The context of this scope. Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope. Accessing this property in general code is not recommended for any purposes except accessing the Job instance for advanced usages. By convention, should contain an instance of a job to enforce structured concurrency." />
      <item value="Return a new Message instance from the global pool. Allows us to avoid allocating new objects in many cases." />
      <item value="Thermometer Measure Data" />
      <item value="hex String" />
      <item value="also" />
      <item value="is Success" />
      <item value="A GATT operation completed successfully" />
      <item value="connect Founded Device" />
      <item value="SEND REQUEST" />
      <item value="code Repeat Check" />
      <item value="Get a BluetoothDevice object for the given Bluetooth hardware address. Valid Bluetooth hardware addresses must be upper case, in a format such as &quot;00:11:22:33:AA:BB&quot;. The helper checkBluetoothAddress is available to validate a Bluetooth address. A BluetoothDevice will always be returned for a valid hardware address, even if this adapter has never seen that device. Params: address – valid Bluetooth MAC address Throws: IllegalArgumentException – if address is invalid" />
      <item value="Set the context for this BluetoothAdapter (only called from BluetoothManager)" />
      <item value="needed Device Found" />
      <item value="regular State" />
      <item value="register For Activity Result" />
      <item value="&lt;p&gt; If the host of this fragment is an {@link ActivityResultRegistryOwner} the {@link ActivityResultRegistry} of the host will be used. Otherwise, this will use the registry of the Fragment's Activity." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1299" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1299" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
        <entry key="VIETNAMESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1659331952533" />
  </component>
</application>