<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="2015" />
    <option name="newTranslationDialogX" value="375" />
    <option name="newTranslationDialogY" value="1110" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="If set, this activity will become the start of a new task on this history stack. A task (from the activity that started it to the next task activity) defines an atomic group of activities that the user can move to. Tasks can be moved to the foreground and background; all of the activities inside of a particular task always remain in the same order. See Tasks and Back Stack for more information about tasks. This flag is generally used by activities that want to present a &quot;launcher&quot; style behavior: they give the user a list of separate things that can be done, which otherwise run completely independently of the activity launching them. When using this flag, if a task is already running for the activity you are now starting, then a new activity will not be started; instead, the current task will simply be brought to the front of the screen with the state it was last in. See FLAG_ACTIVITY_MULTIPLE_TASK for a flag to disable this behavior." />
      <item value="If set, this activity will become the start of a new task on this history stack. A task (from the activity that started it to the next task activity) defines an atomic group of activities that the user can move to. Tasks can be moved to the foreground and background; all of the activities inside of a particular task always remain in the same order. See Tasks and Back Stack for more information about tasks. This flag is generally used by activities that want to present a &quot;launcher&quot; style behavior: they give the user a list of separate things that can be done, which otherwise run completely independently of the activity launching them. When using this flag, if a task is already running for the activity you are now starting, then a new activity will not be started; instead, the current task will simply be brought to the front of the screen with the state it was last in. See FLAG_ACTIVITY_MULTIPLE_TASK for a flag to disable this behavior. This flag can not be used when the caller is requesting a result from the activity being launched." />
      <item value="Request Multiple Permissions" />
      <item value="which" />
      <item value="Requests permissions to be granted to this application. These permissions must be requested in your manifest, they should not be granted to your app, and they should have protection level dangerous, regardless whether they are declared by the platform or a third-party app" />
      <item value="item" />
      <item value="Alternate constructor that can be used to provide a default layout that will be inflated as part of super.onCreate(savedInstanceState). This should generally be called from your constructor that takes no parameters, as is required for API 27 and lower or when using the default android.app.AppComponentFactory. See Also: AppCompatActivity()" />
      <item value="Returns a MutableSet of all keyvalue pairs in this map." />
      <item value="Returns a typed array containing all of the elements of this collection. Allocates an array of runtime type T having its size equal to the size of this collection and populates the array with the elements of this collection" />
      <item value="Attempts to pop the controller's back stack. Analogous to when the user presses the system Back button when the associated navigation host has focus. Returns: true if the stack was popped and the user has been navigated to another destination, false otherwise" />
      <item value="@param requestCode Application specific request code to match with a result reported to {@link OnRequestPermissionsResultCallbackonRequestPermissionsResult(int, String[], int[])}. Should be &gt;= 0." />
      <item value="Requests permissions to be granted to this application. These permissions must be requested in your manifest, they should not be granted to your app, and they should have protection level dangerous, regardless whether they are declared by the platform or a third-party app." />
      <item value="Permissions Request Code" />
      <item value="Find the first denied permission" />
      <item value="shape complaints dialog" />
      <item value="An ActivityResultContract to request a permission" />
      <item value="denied Permission" />
      <item value="Returns a typed array containing all of the elements of this collection. Allocates an array of runtime type T having its size equal to the size of this collection and populates the array with the elements of this collection." />
      <item value="Should show an explanation" />
      <item value="Receive the permissions request result" />
      <item value="Register a request to start an activity for result, designated by the given contract. This creates a record in the registry associated wit this caller, managing request code, as well as conversions tofrom Intent under the hood. This must be called unconditionally, as part of initialization path, typically as a field initializer of an Activity or Fragment. If the host of this fragment is an ActivityResultRegistryOwner the ActivityResultRegistry of the host will be used. Otherwise, this will use the registry of the Fragment's Activity." />
      <item value="launch" />
      <item value="Executes an ActivityResultContract. This method throws android.content.ActivityNotFoundException if there was no Activity found to run the given Intent. Params: input – the input required to execute an ActivityResultContract. Throws: android.content.ActivityNotFoundException" />
      <item value="Not Paired" />
      <item value="Attempts to navigate up in the navigation hierarchy. Suitable for when the user presses the &quot;Up&quot; button marked with a left (or start)-facing arrow in the upper left (or starting) corner of the app UI. The intended behavior of Up differs from Back when the user did not reach the current destination from the application's own task. e.g. if the user is viewing a document or link in the current app in an activity hosted on another app's task where the user clicked the link. In this case the current activity (determined by the context used to create this NavController) will be finished and the user will be taken to an appropriate destination in this app on its own task. Returns: true if navigation was successful, false otherwise" />
      <item value="Callback for the result from requesting permissions. This method is invoked for every call on requestPermissions(Activity, String[], int). Note: It is possible that the permissions request interaction with the user is interrupted. In this case you will receive empty permissions and results arrays which should be treated as a cancellation." />
      <item value="should Show Request Permission Rationale" />
      <item value="Gets whether you should show UI with rationale before requesting a permission. Params: activity – The target activity. permission – A permission your app wants to request. Returns: Whether you should show permission rationale UI" />
      <item value="Gets whether you should show UI with rationale before requesting a permission. Params: activity – The target activity. permission – A permission your app wants to request. Returns: Whether you should show permission rationale UI." />
      <item value="Checks that the specified object reference is not null and throws a customized NullPointerException if it is. This method is designed primarily for doing parameter validation in methods and constructors with multiple parameters, as demonstrated below" />
      <item value="Determine whether you have been granted a particular permission. Params: permission – The name of the permission being checked." />
      <item value="Determine whether you have been granted a particular permission." />
      <item value="Returns an array containing the specified elements." />
      <item value="register For Activity Result" />
      <item value="on Bluetooth Dialog Button Click" />
      <item value="permissions Granted" />
      <item value="Check Permissions Fragment" />
      <item value="Add Context instance to Koin container @param androidContext - Context" />
      <item value="create Custom Back Pressed" />
      <item value="view Lifecycle Owner" />
      <item value="Add a new {@link OnBackPressedCallback}. Callbacks are invoked in the reverse order in which they are added, so this newly added {@link OnBackPressedCallback} will be the first callback to receive a callback if {@link onBackPressed()} is called. &lt;p&gt; This method is &lt;strong&gt;not&lt;strong&gt; {@link Lifecycle} aware - if you'd like to ensure that you only get callbacks when at least {@link Lifecycle.StateSTARTED started}, use {@link addCallback(LifecycleOwner, OnBackPressedCallback)}. It is expected that you call {@link OnBackPressedCallbackremove()} to manually remove your callback." />
      <item value="before" />
      <item value="Called getViewLifecycleOwner() but onCreateView() returned null" />
      <item value="handle On Back Pressed" />
      <item value="Create a OnBackPressedCallback. Params: enabled – The default enabled state for this callback. See Also: setEnabled(boolean)" />
      <item value="Caused by: java.lang.IllegalStateException: Can't access the Fragment View's LifecycleOwner when getView() is null i.e., before onCreateView() or after onDestroyView()" />
      <item value="ccess the Fragment View's LifecycleOwner when getView() is null i.e., before onCreateView() or after onDestroyView()" />
      <item value="is Valid" />
      <item value="Receive callbacks to a new OnBackPressedCallback when the given LifecycleOwner is at least started. This will automatically call addCallback(OnBackPressedCallback) and remove the callback as the lifecycle state changes. As a corollary, if your lifecycle is already at least started, calling this method will result in an immediate call to addCallback(OnBackPressedCallback). When the LifecycleOwner is destroyed, it will automatically be removed from the list of callbacks. The only time you would need to manually call OnBackPressedCallback.remove() is if you'd like to remove the callback prior to destruction of the associated lifecycle. If the Lifecycle is already destroyed when this method is called, the callback will not be added. Params: owner – The LifecycleOwner which controls when the callback should be invoked onBackPressedCallback – The callback to add See Also: onBackPressed()" />
      <item value="This is the class for text whose content and markup can both be changed." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="926" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="928" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1651643940158" />
  </component>
</application>