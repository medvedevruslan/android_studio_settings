<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="2003" />
    <option name="newTranslationDialogX" value="4625" />
    <option name="newTranslationDialogY" value="1337" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="final Permission" />
      <item value="try Connect Paired Device" />
      <item value="Construct a PendingIntent to the deep link destination. This constructs the entire task stack needed. You must have set a NavGraph and set a destination before calling this method. Returns: a PendingIntent constructed with TaskStackBuilder.getPendingIntent to deep link to the given destination" />
      <item value="Starts to listen the given source LiveData, onChanged observer will be called when source value was changed. onChanged callback will be called only when this MediatorLiveData is active. If the given LiveData is already added as a source but with a different Observer, IllegalArgumentException will be thrown. Params: source – the LiveData to listen to onChanged – The observer that will receive the events Type parameters: &lt;S&gt; – The type of data hold by source LiveData" />
      <item value="add Source" />
      <item value="Similar to startService(Intent), but with an implicit promise that the Service will call startForeground(int, android.app.Notification) once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically crash the process, in which case an internal exception ForegroundServiceDidNotStartInTimeException is logged on logcat on devices running SDK Version Build.VERSION_CODES.S or later. On older Android versions, an internal exception RemoteServiceException is logged instead, with a corresponding message. Unlike the ordinary startService(Intent), this method can be used at any time, regardless of whether the app hosting the service is in a foreground state. Note: Beginning with SDK Version Build.VERSION_CODES.S, apps targeting SDK Version Build.VERSION_CODES.S or higher are not allowed to start foreground services from the background. See Behavior changes: Apps targeting Android 12 for more details. Params: service – Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call. Returns: If the service is being started or is already running, the ComponentName of the actual service that was started is returned; else if the service does not exist null is returned. Throws: SecurityException – If the caller does not have permission to access the service or the service can not be found. android.app.ForegroundServiceStartNotAllowedException – If the caller app's targeting API is Build.VERSION_CODES.S or later, and the foreground service is restricted from start due to background restriction. See Also: stopService, android.app.Service.startForeground(int, android.app.Notification)" />
      <item value="Attempt to invoke virtual method 'void androidx.lifecycle.MutableLiveData.setValue(java.lang.Object)' on a null object reference" />
      <item value="java.lang.NullPointerException: Attempt to invoke virtual method 'void androidx.lifecycle.MutableLiveData.setValue(java.lang.Object)' on a null object reference" />
      <item value="Check to see whether this activity is in the process of being destroyed in order to be recreated with a new configuration. This is often used in onStop to determine whether the state needs to be cleaned up or will be passed on to the next instance of the activity via onRetainNonConfigurationInstance(). Returns: If the activity is being torn down in order to be recreated with a new configuration, returns true; else returns false." />
      <item value="Flag for bindService: automatically create the service as long as the binding exists. Note that while this will create the service, its android.app.Service.onStartCommand method will still only be called due to an explicit call to startService. Even without that, though, this still provides you with access to the service object while the service is created. Note that prior to Build.VERSION_CODES.ICE_CREAM_SANDWICH, not supplying this flag would also impact how important the system consider's the target service's process to be. When set, the only way for it to be raised was by binding from a service in which case it will only be important when that activity is in the foreground. Now to achieve this behavior you must explicitly supply the new flag BIND_ADJUST_WITH_ACTIVITY. For compatibility, old applications that don't specify BIND_AUTO_CREATE will automatically have the flags BIND_WAIVE_PRIORITY and BIND_ADJUST_WITH_ACTIVITY set for them in order to achieve the same result." />
      <item value="launch Service" />
      <item value="launche Service" />
      <item value="launcher Service" />
      <item value="resolve" />
      <item value="needed Device Found" />
      <item value="Data Received" />
      <item value="Set the time that the event occurred. Notifications in the panel are sorted by this time. For apps targeting Build.VERSION_CODES.N and above, this time is not shown anymore by default and must be opted into using setShowWhen(boolean)" />
      <item value="input Command" />
      <item value="Stops to listen the given LiveData. Params: toRemote – LiveData to stop to listen Type parameters: &lt;S&gt; – the type of data hold by source LiveData" />
      <item value="Calls the specified function block with the given receiver as its receiver and returns its result. For detailed usage information see the documentation for scope functions ." />
      <item value="route" />
      <item value="wait Delay" />
      <item value="Retrieve the current back stack. Returns: The current back stack." />
      <item value="Returns true if the receiver is currently processing an ordered broadcast." />
      <item value="shipment Busy" />
      <item value="Return true if Bluetooth is currently enabled and ready for use. Equivalent to: getBluetoothState() == STATE_ON Returns: true if the local adapter is turned on" />
      <item value="handle" />
      <item value="Simple Result" />
      <item value="By overriding invoke, we allow use cases to be called as &quot;invoking&quot;" />
      <item value="Sends the specified element to this channel, suspending the caller while the buffer of this channel is full or if it does not exist, or throws an exception if the channel is closed for send (see close for details). Closing a channel after this function has suspended does not cause this suspended send invocation to abort, because closing a channel is conceptually like sending a special &quot;close token&quot; over this channel. All elements sent over the channel are delivered in first-in first-out order. The sent element will be delivered to receivers before the close token. This suspending function is cancellable. If the Job of the current coroutine is cancelled or completed while this function is suspended, this function immediately resumes with a CancellationException. There is a prompt cancellation guarantee. If the job was cancelled while this function was suspended, it will not resume successfully. The send call can send the element to the channel, but then throw CancellationException, thus an exception should not be treated as a failure to deliver the element. See &quot;Undelivered elements&quot; section in Channel documentation for details on handling undelivered elements. Note that this function does not check for cancellation when it is not suspended. Use yield or CoroutineScope.isActive to periodically check for cancellation in tight loops if needed. This function can be used in select invocations with the onSend clause. Use trySend to try sending to this channel without waiting." />
      <item value="Performs the given action for each received element and cancels the channel after the execution of the block. If you need to iterate over the channel without consuming it, a regular for loop should be used instead. The operation is terminal. This function consumes all elements of the original ReceiveChannel." />
      <item value="consume Each" />
      <item value="process Stream" />
      <item value="This method will be called when this ViewModel is no longer used and will be destroyed. It is useful when ViewModel observes some data and you need to clear this subscription to prevent a leak of this ViewModel." />
      <item value="The context of this scope. Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope. Accessing this property in general code is not recommended for any purposes except accessing the Job instance for advanced usages. By convention, should contain an instance of a job to enforce structured concurrency." />
      <item value="handle State" />
      <item value="handle Success" />
      <item value="handle Result" />
      <item value="Failed" />
      <item value="Failure" />
      <item value="Data" />
      <item value="reason" />
      <item value="Returns the value associated with the given key, or defaultValue if no mapping of the desired type exists for the given key. Params: key – a String defaultValue – Value to return if key does not exist Returns: a boolean value" />
      <item value="Batch" />
      <item value="on Batch Scan Results" />
      <item value="Post a notification to be shown in the status bar. If a notification with the same id has already been posted by your application and has not yet been canceled, it will be replaced by the updated information. Params: id – An identifier for this notification unique within your application. notification – A Notification object describing what to show the user. Must not be null." />
      <item value="Returns the runtime Java class of this object." />
      <item value="Returns a KClass instance corresponding to the given Java Class instance." />
      <item value="to avoid binary compatibility issues." />
      <item value="issues" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1198" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1198" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1656306537062" />
  </component>
</application>