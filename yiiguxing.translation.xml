<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="1997" />
    <option name="newTranslationDialogX" value="5005" />
    <option name="newTranslationDialogY" value="1307" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="cause the original cause of this exception" />
      <item value="cause" />
      <item value="on Completed" />
      <item value="Title Refresh Callback" />
      <item value="Annotates fields that reference rules or methods that return a rule. A field must be public, not static, and a subtype of org.junit.rules.TestRule (preferred) or org.junit.rules.MethodRule. A method must be public, not static, and must return a subtype of org.junit.rules.TestRule (preferred) or org.junit.rules.MethodRule. The org.junit.runners.model.Statement passed to the org.junit.rules.TestRule will run any Before methods, then the Test method, and finally any After methods, throwing an exception if any of these fail. If there are multiple annotated Rules on a class, they will be applied in order of methods first, then fields. However, if there are multiple fields (or methods) they will be applied in an order that depends on your JVM's implementation of the reflection API, which is undefined, in general. Rules defined by fields will always be applied after Rules defined by methods, i.e. the Statements returned by the former will be executed around those returned by the latter." />
      <item value="A JUnit Test Rule that swaps the background executor used by the Architecture Components with a different one which executes each task synchronously. You can use this rule for your host side tests that use Architecture Components." />
      <item value="Before" />
      <item value="subject" />
      <item value="instant Task Executor Rule" />
      <item value="instant" />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion." />
      <item value="Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion. Params: task – the task to submit" />
      <item value="An executor service that can run [Runnable]s off the main thread." />
      <item value="Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown. Params: nThreads – the number of threads in the pool Returns: the newly created thread pool Throws: IllegalArgumentException – if nThreads &lt;= 0" />
      <item value="Executors" />
      <item value="_spinner" />
      <item value="Could not determine the dependencies of task ':start:compileDebugJavaWithJavac'. &gt; Cannot query the value of property 'bootClasspath' because it has no value available." />
      <item value="The context of this scope. Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope. Accessing this property in general code is not recommended for any purposes except accessing the Job instance for advanced usages. By convention, should contain an instance of a job to enforce structured concurrency." />
      <item value="Return a new Message instance from the global pool. Allows us to avoid allocating new objects in many cases." />
      <item value="Thermometer Measure Data" />
      <item value="hex String" />
      <item value="also" />
      <item value="is Success" />
      <item value="A GATT operation completed successfully" />
      <item value="connect Founded Device" />
      <item value="SEND REQUEST" />
      <item value="code Repeat Check" />
      <item value="Get a BluetoothDevice object for the given Bluetooth hardware address. Valid Bluetooth hardware addresses must be upper case, in a format such as &quot;00:11:22:33:AA:BB&quot;. The helper checkBluetoothAddress is available to validate a Bluetooth address. A BluetoothDevice will always be returned for a valid hardware address, even if this adapter has never seen that device. Params: address – valid Bluetooth MAC address Throws: IllegalArgumentException – if address is invalid" />
      <item value="Set the context for this BluetoothAdapter (only called from BluetoothManager)" />
      <item value="needed Device Found" />
      <item value="regular State" />
      <item value="register For Activity Result" />
      <item value="&lt;p&gt; If the host of this fragment is an {@link ActivityResultRegistryOwner} the {@link ActivityResultRegistry} of the host will be used. Otherwise, this will use the registry of the Fragment's Activity." />
      <item value="get Denied Permission" />
      <item value="pressure Measurement Fragment" />
      <item value="entries" />
      <item value="HANDOVER" />
      <item value="ACCEPT HANDOVER" />
      <item value="Unable to resume activity {com.example.clean_pre_trip_controlcom.example.clean_pre_trip_control.presentation.MainActivity}: java.lang.IllegalArgumentException: Unknown permission: [android.permission.ACCESS_COARSE_LOCATION]" />
      <item value="not attached to a context." />
      <item value="not attached to an activity." />
      <item value="check First Try After Should Show" />
      <item value="request Permission" />
      <item value="first Check All Permissions" />
      <item value="if should Show true" />
      <item value="By overriding invoke, we allow use cases to be called as &quot;invoking&quot;" />
      <item value="Worker" />
      <item value="daemon" />
      <item value="if should Show Request Permission Rationale_" />
      <item value="key – The name of the preference to retrieve. defValue – Value to return if this preference does not exist. Returns: Returns the preference value if it exists, or defValue. Throws ClassCastException if there is a preference with this name that is not a boolean" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1281" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1281" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658746132034" />
  </component>
</application>