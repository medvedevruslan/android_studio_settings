<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="1995" />
    <option name="newTranslationDialogX" value="5005" />
    <option name="newTranslationDialogY" value="1307" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Sets a query string in the text field and optionally submits the query as well. Params: query – the query string. This replaces any query text already present in the text field. submit – whether to submit the query right now or only update the contents of text field." />
      <item value="Sets a query string in the text field and optionally submits the query as well." />
      <item value="Manifest merger failed : android:exported needs to be explicitly specified for element &lt;activitycom.example.flow_mvvm_sample.ui.top.TopActivity&gt;. Apps targeting Android 12 and higher are required to specify an explicit value for `android:exported` when the corresponding component has an intent filter defined." />
      <item value="Caused by: org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfigurationArtifactResolveException: Could not resolve all files for configuration ':app:debugCompileClasspath'." />
      <item value="An exception occurred applying plugin request [id: 'com.android.application']" />
      <item value="&gt; Failed to apply plugin 'com.android.internal.application'." />
      <item value="A problem occurred evaluating project ':app'." />
      <item value="Definition Parameters" />
      <item value="Build a DefinitionParameters" />
      <item value="current" />
      <item value="Returns the query string currently in the text field. Returns: the query string" />
      <item value="submit" />
      <item value="Notify any registered observers that the data set has changed. There are two different classes of data change events, item changes and structural changes. Item changes are when a single item has its data updated but no positional changes have occurred. Structural changes are when items are inserted, removed or moved within the data set. This event does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views. RecyclerView will attempt to synthesize visible structural change events for adapters that report that they have stable IDs when this method is used. This can help for the purposes of animation and visual object persistence but individual item views will still need to be rebound and relaid out. If you are writing an adapter it will always be more efficient to use the more specific change events if you can. Rely on notifyDataSetChanged() as a last resort." />
      <item value="Pending" />
      <item value="execute Pending" />
      <item value="execute Pending Bindings" />
      <item value="Evaluates the pending bindings, updating any Views that have expressions bound to modified variables. This must be run on the UI thread." />
      <item value="Returns an empty read-only list. The returned list is" />
      <item value="on Bind View Holder" />
      <item value="Is set when VH is bound from the adapter and cleaned right before it is sent to RecyclerView.RecycledViewPool." />
      <item value="View Holder" />
      <item value="state In" />
      <item value="The starting of the sharing coroutine is controlled by the started parameter, as explained in the documentation for shareIn operator." />
      <item value="The stateIn operator is useful in situations when there is a cold flow that provides updates to the value of some state and is expensive to create andor to maintain, but there are multiple subscribers that need to collect the most recent state value. For example, consider a flow of state updates coming from a backend over the expensive network connection, taking a lot of time to establish. Conceptually it might be implemented like this:" />
      <item value="See the StateFlow documentation for the general concepts of state flows. The starting of the sharing coroutine is controlled by the started parameter, as explained in the documentation for shareIn operator." />
      <item value="sharing the most recently emitted value from a single running instance of the upstream flow with multiple downstream subscribers." />
      <item value="sharing the most recently" />
      <item value="Converts a cold Flow into a hot StateFlow that is started in the given coroutine scope, sharing the most recently emitted value from a single running instance of the upstream flow with multiple downstream subscribers. See the StateFlow documentation for the general concepts of state flows." />
      <item value="Returns a flow containing the results of applying the given [transform] function to each value of the original flow." />
      <item value="Returns a flow that wraps each element into [IndexedValue], containing value and its index (starting from zero)." />
      <item value="bind" />
      <item value="Immutable URI reference. A URI reference includes a URI and a fragment, the component of the URI following a ''. Builds and parses URI references which conform to RFC 2396 . In the interest of performance, this class performs little to no validation. Behavior is undefined for invalid input. This class is very forgiving--in the face of invalid input, it will return garbage rather than throw an exception unless otherwise specified." />
      <item value="include" />
      <item value="This can be useful for creating [Map] literals with less noise, for example:" />
      <item value="Creates a tuple of type [Pair] from this and [that]." />
      <item value="tuple" />
      <item value="Pair" />
      <item value="Represents a generic pair of two values." />
      <item value="Modal bottom sheet. This is a version of DialogFragment that shows a bottom sheet using BottomSheetDialog instead of a floating dialog" />
      <item value="Bottom Sheet Dialog Fragment" />
      <item value="Path" />
      <item value="Returns a flow that switches to a new flow produced by transform function every time the original flow emits a value. When the original flow emits a new value, the previous flow produced by transform block is cancelled." />
      <item value="Returns a flow that emits elements from the original flow transformed by transform function. When the original flow emits a new value, computation of the transform block for previous value is cancelled." />
      <item value="Returns a flow that switches to a new flow produced by transform function every time the original flow emits a value. When the original flow emits a new value, the previous flow produced by transform block is cancelled. For example, the following flow:" />
      <item value="eturns a flow that switches to a new flow produced by transform function every time the original flow emits a value. When the original flow emits a new value, the previous flow produced by transform block is cancelled. For example, the following flow: flow { emit(&quot;a&quot;) delay(100) emit(&quot;b&quot;) }.flatMapLatest { value -&gt; flow { emit(value) delay(200) emit(value + &quot;_last&quot;) } } produces a b b_last This operator is buffered by default and size of its output buffer can be changed by applying subsequent buffer operator." />
      <item value="Returns a flow that invokes the given [action] before each value of the upstream flow is emitted downstream." />
      <item value="Represents a 32-bit signed integer. On the JVM, non-nullable values of this type are represented as values of the primitive type int." />
      <item value="Returns the absolute value of the given value n. Special cases:" />
      <item value="check If It Less Null" />
      <item value="Returns a flow that switches to a new flow produced by transform function every time the original flow emits a value. When the original flow emits a new value, the previous flow produced by transform block is cancelled. For example, the following flow: flow { emit(&quot;a&quot;) delay(100) emit(&quot;b&quot;) }.flatMapLatest { value -&gt; flow { emit(value) delay(200) emit(value + &quot;_last&quot;) } } produces a b b_last This operator is buffered by default and size of its output buffer can be changed by applying subsequent buffer operator." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1531" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1531" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
        <entry key="SUNDANESE" value="1" />
        <entry key="JAVANESE" value="1" />
        <entry key="VIETNAMESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1661143807221" />
  </component>
</application>