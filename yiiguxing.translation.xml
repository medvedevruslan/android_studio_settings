<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="1995" />
    <option name="newTranslationDialogX" value="5005" />
    <option name="newTranslationDialogY" value="1307" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="stop Scan Before Connect Device" />
      <item value="Creates a tuple of type [Pair] from this and [that]." />
      <item value="java.lang.NoSuchMethodError: No virtual method getStatusBle()LkotlinxcoroutinesflowStateFlow; in class Lcomexampleclean_pre_trip_controlpresentationuibleBleStatusOwner; or its super classes (declaration of 'com.example.clean_pre_trip_control.presentation.ui.ble.BleStatusOwner' appears in datadatacom.example.clean_pre_trip_controlcode_cache.overlaybase.apkclasses21.dex) at com.example.clean_pre_trip_control.presentation.ui.ble.BleServicescanCallback1onScanResult1.invokeSuspend(BleService.kt:165)" />
      <item value="[FlowCollector] is used as an intermediate or a terminal collector of the flow and represents an entity that accepts values emitted by the [Flow]." />
      <item value="Returns a flow that switches to a new flow produced by transform function every time the original flow emits a value. When the original flow emits a new value, the previous flow produced by transform block is cancelled." />
      <item value="success Data" />
      <item value="Success" />
      <item value="sealed" />
      <item value="Regular" />
      <item value="set Test To Checkup In Db Use Case" />
      <item value="set Final Test To Checkup In Db Use Case" />
      <item value="Network Bound Repository" />
      <item value="The starting of the sharing coroutine is controlled by the started parameter, as explained in the documentation for shareIn operator." />
      <item value="Converts a cold Flow into a hot StateFlow that is started in the given coroutine scope, sharing the most recently emitted value from a single running instance of the upstream flow with multiple downstream subscribers. See the StateFlow documentation for the general concepts of state flows. The starting of the sharing coroutine is controlled by the started parameter, as explained in the documentation for shareIn operator. The stateIn operator is useful in situations when there is a cold flow that provides updates to the value of some state and is expensive to create andor to maintain, but there are multiple subscribers that need to collect the most recent state value. For example, consider a flow of state updates coming from a backend over the expensive network connection, taking a lot of time to establish. Conceptually it might be implemented like this:" />
      <item value="submit Event" />
      <item value="Returns a flow that invokes the given [action] before each value of the upstream flow is emitted downstream." />
      <item value="source" />
      <item value="state In" />
      <item value="Converts a cold Flow into a hot StateFlow that is started in the given coroutine scope, sharing the most recently emitted value from a single running instance of the upstream flow with multiple downstream subscribers. See the StateFlow documentation for the general concepts of state flows." />
      <item value="Changes the context where this flow is executed to the given context. This operator is composable and affects only preceding operators that do not have its own context. This operator is context preserving: context does not leak into the downstream flow." />
      <item value="Returns a flow that invokes the given action before this flow starts to be collected." />
      <item value="try Update Recent Plants Cache" />
      <item value="Helper function to call a data load function with a loading spinner; errors will trigger a snackbar." />
      <item value="Returns a [LiveData] mapped from `this` LiveData by applying [transform] to each value set on `this` LiveData." />
      <item value="Returns a LiveData mapped from the input this LiveData by applying transform to each value set on this." />
      <item value="switch Map" />
      <item value="Add the given LiveData as a source, similar to MediatorLiveData.addSource. Calling this method will remove any source that was yielded before via emitSource" />
      <item value="custom Sort Order" />
      <item value="Fetch" />
      <item value="position For Item" />
      <item value="mapped" />
      <item value="according" />
      <item value="Creates a Mutex instance. The mutex created is fair: lock is granted in first come, first served order. Params: locked - initial state of the mutex" />
      <item value="fair" />
      <item value="Creates a Mutex instance. The mutex created is fair: lock is granted in first come, first served order. Params: locked - initial state of the mutex." />
      <item value="Applies the given transform function to each element of the original collection and appends the results to the given destination." />
      <item value="Returns a list containing the results of applying the given transform function to each element in the original collection. Samples: samples.collections.Collections.Transformations.map Unresolved" />
      <item value="Get the current cached value, or await the completion of [block]." />
      <item value="Cache the first non-error result from an async computation passed as [block]. Usage: ``` val cachedSuccess: CacheOnSuccess&lt;Int&gt; = CacheOnSuccess(onErrorFallback = { 3 }) { delay(1_000) compute value using coroutines 5 } cachedSuccess.getOrAwait() get the result from the cache, calling [block], or fallback on exception ``` @param onErrorFallback: Invoke this if [block] throws exception other than cancellation, the result of this lambda will be returned for this call to [getOrAwait] but will not be cached for future calls to [getOrAwait] @param block Suspending lambda that produces the cached value. The first non-exceptional value returned by [block] will be cached, and future calls to [getOrAwait] will return the cached value or throw a [CancellationException]." />
      <item value="plants List Sort Order Cache" />
      <item value="Returns a Flow whose values are generated with transform function by combining the most recently emitted values by each flow. It can be demonstrated with the following example: val flow = flowOf(1, 2).onEach { delay(10) } val flow2 = flowOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).onEach { delay(15) } flow.combine(flow2) { i, s -&gt; i.toString() + s }.collect { println(it) Will print &quot;1a 2a 2b 2c&quot; } This function is a shorthand for flow.combineTransform(flow2) { a, b -&gt; emit(transform(a, b)) }" />
      <item value="combine" />
      <item value="Create a flow that calls a single function" />
      <item value="sort Order" />
      <item value="Classes which inherit from this interface have a defined total ordering between their instances." />
      <item value="apply Sort" />
      <item value="Comparable Pair" />
      <item value="Returns the index of the first occurrence of the specified element in the list, or -1 if the specified element is not contained in the list." />
      <item value="Returns the index of the last occurrence of the specified element in the list, or -1 if the specified element is not contained in the list." />
      <item value="occurrence" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1647" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1647" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
        <entry key="SUNDANESE" value="1" />
        <entry key="JAVANESE" value="1" />
        <entry key="VIETNAMESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1663065062176" />
  </component>
</application>