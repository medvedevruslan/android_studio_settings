<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="2027" />
    <option name="newTranslationDialogX" value="720" />
    <option name="newTranslationDialogY" value="955" />
    <histories>
      <item value="is Valid" />
      <item value="Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception)." />
      <item value="Returns a string representation of the object." />
      <item value="ndicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements: Reflexive: for any non-null value x, x.equals(x) should return true. Symmetric: for any non-null values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. Transitive: for any non-null values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. Consistent: for any non-null values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. Never equal to null: for any non-null value x, x.equals(null) should return fals" />
      <item value="The root of the Kotlin class hierarchy. Every Kotlin class has Any as a superclass." />
      <item value="Receiver's interface to Channel." />
      <item value="state" />
      <item value="state Block" />
      <item value="Failure" />
      <item value="end region" />
      <item value="endregion" />
      <item value="By overriding invoke, we allow use cases to be called as &quot;invoking&quot;" />
      <item value="invoke" />
      <item value="region" />
      <item value="region Functions" />
      <item value="Get person from persistence and send it, synchronous" />
      <item value="If a list is already being displayed, a diff will be computed on a background thread, which will dispatch Adapter.notifyItem events on the main thread." />
      <item value="Submits a new list to be diffed, and displayed." />
      <item value="Submits a new list to be diffed, and displayed. &lt;p&gt; If a list is already being displayed, a diff will be computed on a background thread, which will dispatch Adapter.notifyItem events on the main thread. @param list The new list to be displayed." />
      <item value="child Count" />
      <item value="The total number of items in the dataset after the last load" />
      <item value="Add a listener that will be notified of any changes in scroll state or position. Components that add a listener should take care to remove it when finished. Other components that take ownership of a view may call clearOnScrollListeners() to remove all attached listeners" />
      <item value="add On Scroll Listener" />
      <item value="receive Channel" />
      <item value="handle Success" />
      <item value="fade Animation" />
      <item value="clear On Scroll Listeners" />
      <item value="Evaluates the pending bindings, updating any Views that have expressions bound to modified variables. This &lt;b&gt;must&lt;b&gt; be run on the UI thread." />
      <item value="Cannot resolve type 'recyclerViewModel'" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance. &lt;p&gt; &lt;b&gt;Example&lt;b&gt; &lt;pre&gt; final class MyDetailsLookup extends ItemDetailsLookup&lt;Uri&gt; { private final RecyclerView mRecyclerView; MyDetailsLookup(RecyclerView recyclerView) { mRecyclerView = recyclerView; } public @Nullable ItemDetails&lt;Uri&gt; getItemDetails(@NonNull MotionEvent e) { View view = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (view != null) { ViewHolder holder = mRecyclerView.getChildViewHolder(view); if (holder instanceof MyHolder) { return ((MyHolder) holder).getItemDetails(); } } return null;" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance." />
      <item value="Item Details Lookup" />
      <item value="The Selection library calls {@link getItemDetails(MotionEvent)} when it needs access to information about the area andor {@link ItemDetails} under a {@link MotionEvent}. Your implementation must negotiate {@link RecyclerView.ViewHolder ViewHolder} lookup with the corresponding RecyclerView instance, and the subsequent conversion of the ViewHolder instance to an {@link ItemDetails} instance. &lt;p&gt; &lt;b&gt;Example&lt;b&gt; &lt;pre&gt; final class MyDetailsLookup extends ItemDetailsLookup&lt;Uri&gt; { private final RecyclerView mRecyclerView; MyDetailsLookup(RecyclerView recyclerView) { mRecyclerView = recyclerView; } public @Nullable ItemDetails&lt;Uri&gt; getItemDetails(@NonNull MotionEvent e) { View view = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (view != null) { ViewHolder holder = mRecyclerView.getChildViewHolder(view); if (holder instanceof MyHolder) { return ((MyHolder) holder).getItemDetails(); } } return null; } }" />
      <item value="save Complaints" />
      <item value="Unable to make protected void" />
      <item value="Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected void java.util.ResourceBundle.setParent(java.util.ResourceBundle) accessible: module java.base does not &quot;opens java.util&quot; to unnamed module @3e07d849" />
      <item value="Template Fragment" />
      <item value="event Network Error" />
      <item value="_event Network Error" />
      <item value="hide" />
      <item value="Dev Byte Network" />
      <item value="Returns a list containing the results of applying the given [transform] function to each element in the original collection." />
      <item value="Returns a list containing the results of applying the given transform function to each element in the original collection" />
      <item value="instances" />
      <item value="permit functional composition" />
      <item value="permit" />
      <item value="Transformation methods for {@link LiveData}. &lt;p&gt; These methods permit functional composition and delegation of {@link LiveData} instances. The transformations are calculated lazily, and will run only when the returned {@link LiveData} is observed. Lifecycle behavior is propagated from the input {@code source} {@link LiveData} to the returned one." />
      <item value="suspend" />
      <item value="REPLACE" />
      <item value="OnConflict strategy constant to replace the old data and continue the transaction. An Insert DAO method that returns the inserted rows ids will never return -1 since this strategy will always insert a row even if there is a conflict" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="837" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="837" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1649652957837" />
  </component>
</application>