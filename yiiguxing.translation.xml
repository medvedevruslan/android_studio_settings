<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="626" />
    <option name="newTranslationDialogWidth" value="2001" />
    <option name="newTranslationDialogX" value="4625" />
    <option name="newTranslationDialogY" value="1337" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Scan using highest duty cycle. It's recommended to only use this mode when the application is running in the foreground." />
      <item value="Runs a new coroutine and blocks the current thread interruptibly until its completion. This function should not be used from a coroutine. It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in main functions and in tests. The default CoroutineDispatcher for this builder is an internal implementation of event loop that processes continuations in this blocked thread until the completion of this coroutine. See CoroutineDispatcher for the other implementations that are provided by kotlinx.coroutines. When CoroutineDispatcher is explicitly specified in the context, then the new coroutine runs in the context of the specified dispatcher while the current thread is blocked. If the specified dispatcher is an event loop of another runBlocking, then this invocation uses the outer event loop. If this blocked thread is interrupted (see Thread.interrupt), then the coroutine job is cancelled and this runBlocking invocation throws InterruptedException. See newCoroutineContext for a description of debugging facilities that are available for a newly created coroutine. Params: context - the context of the coroutine. The default value is an event loop on the current thread. block - the coroutine code." />
      <item value="try Connect Paired Device" />
      <item value="Stop the service, if it was previously started. This is the same as calling" />
      <item value="input Command" />
      <item value="Failure" />
      <item value="Failure Ble" />
      <item value="Failed" />
      <item value="Failed Ble" />
      <item value="work With Result Status" />
      <item value="worker With Result Status" />
      <item value="LiveData which publicly exposes setValue(T) and postValue(T) method. Type parameters: &lt;T&gt; – The type of data hold by this instance" />
      <item value="Creates a MutableLiveData initialized with the given value. Params: value – initial value" />
      <item value="state" />
      <item value="LiveData subclass which may observe other LiveData objects and react on OnChanged events from them. This class correctly propagates its activeinactive states down to source LiveData objects. Consider the following scenario: we have 2 instances of LiveData, let's name them liveData1 and liveData2, and we want to merge their emissions in one object: liveDataMerger. Then, liveData1 and liveData2 will become sources for the MediatorLiveData liveDataMerger and every time onChanged callback is called for either of them, we set a new value in liveDataMerger." />
      <item value="Called by the system when the service is first created. Do not call this method directly." />
      <item value="Create a listening, insecure RFCOMM Bluetooth socket with Service Record. The link key is not required to be authenticated, i.e the communication may be vulnerable to Person In the Middle attacks. For Bluetooth 2.1 devices, the link will be encrypted, as encryption is mandatory. For legacy devices (pre Bluetooth 2.1 devices) the link will not be encrypted. Use listenUsingRfcommWithServiceRecord, if an encrypted and authenticated communication channel is desired. Use BluetoothServerSocket.accept to retrieve incoming connections from a listening BluetoothServerSocket. The system will assign an unused RFCOMM channel to listen on. The system will also register a Service Discovery Protocol (SDP) record with the local SDP server containing the specified UUID, service name, and auto-assigned channel. Remote Bluetooth devices can use the same UUID to query our SDP server and discover which channel to connect to. This SDP record will be removed when this socket is closed, or if this application closes unexpectedly. Use BluetoothDevice.createRfcommSocketToServiceRecord to connect to this socket from another device using the same UUID. Params: name – service name for SDP record uuid – uuid for SDP record Returns: a listening RFCOMM BluetoothServerSocket Throws: IOException – on error, for example Bluetooth not available, or insufficient permissions, or channel in use." />
      <item value="NAME INSECURE" />
      <item value="needed Device Found" />
      <item value="date And Time Assembly" />
      <item value="data Received" />
      <item value="Allocates a Date object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond. See Also: System.currentTimeMillis()" />
      <item value="Connected Thread" />
      <item value="final Permission" />
      <item value="Construct a PendingIntent to the deep link destination. This constructs the entire task stack needed. You must have set a NavGraph and set a destination before calling this method. Returns: a PendingIntent constructed with TaskStackBuilder.getPendingIntent to deep link to the given destination" />
      <item value="Starts to listen the given source LiveData, onChanged observer will be called when source value was changed. onChanged callback will be called only when this MediatorLiveData is active. If the given LiveData is already added as a source but with a different Observer, IllegalArgumentException will be thrown. Params: source – the LiveData to listen to onChanged – The observer that will receive the events Type parameters: &lt;S&gt; – The type of data hold by source LiveData" />
      <item value="add Source" />
      <item value="Similar to startService(Intent), but with an implicit promise that the Service will call startForeground(int, android.app.Notification) once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically crash the process, in which case an internal exception ForegroundServiceDidNotStartInTimeException is logged on logcat on devices running SDK Version Build.VERSION_CODES.S or later. On older Android versions, an internal exception RemoteServiceException is logged instead, with a corresponding message. Unlike the ordinary startService(Intent), this method can be used at any time, regardless of whether the app hosting the service is in a foreground state. Note: Beginning with SDK Version Build.VERSION_CODES.S, apps targeting SDK Version Build.VERSION_CODES.S or higher are not allowed to start foreground services from the background. See Behavior changes: Apps targeting Android 12 for more details. Params: service – Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call. Returns: If the service is being started or is already running, the ComponentName of the actual service that was started is returned; else if the service does not exist null is returned. Throws: SecurityException – If the caller does not have permission to access the service or the service can not be found. android.app.ForegroundServiceStartNotAllowedException – If the caller app's targeting API is Build.VERSION_CODES.S or later, and the foreground service is restricted from start due to background restriction. See Also: stopService, android.app.Service.startForeground(int, android.app.Notification)" />
      <item value="Attempt to invoke virtual method 'void androidx.lifecycle.MutableLiveData.setValue(java.lang.Object)' on a null object reference" />
      <item value="java.lang.NullPointerException: Attempt to invoke virtual method 'void androidx.lifecycle.MutableLiveData.setValue(java.lang.Object)' on a null object reference" />
      <item value="Check to see whether this activity is in the process of being destroyed in order to be recreated with a new configuration. This is often used in onStop to determine whether the state needs to be cleaned up or will be passed on to the next instance of the activity via onRetainNonConfigurationInstance(). Returns: If the activity is being torn down in order to be recreated with a new configuration, returns true; else returns false." />
      <item value="Flag for bindService: automatically create the service as long as the binding exists. Note that while this will create the service, its android.app.Service.onStartCommand method will still only be called due to an explicit call to startService. Even without that, though, this still provides you with access to the service object while the service is created. Note that prior to Build.VERSION_CODES.ICE_CREAM_SANDWICH, not supplying this flag would also impact how important the system consider's the target service's process to be. When set, the only way for it to be raised was by binding from a service in which case it will only be important when that activity is in the foreground. Now to achieve this behavior you must explicitly supply the new flag BIND_ADJUST_WITH_ACTIVITY. For compatibility, old applications that don't specify BIND_AUTO_CREATE will automatically have the flags BIND_WAIVE_PRIORITY and BIND_ADJUST_WITH_ACTIVITY set for them in order to achieve the same result." />
      <item value="launch Service" />
      <item value="launche Service" />
      <item value="launcher Service" />
      <item value="resolve" />
      <item value="Data Received" />
      <item value="Set the time that the event occurred. Notifications in the panel are sorted by this time. For apps targeting Build.VERSION_CODES.N and above, this time is not shown anymore by default and must be opted into using setShowWhen(boolean)" />
      <item value="Stops to listen the given LiveData. Params: toRemote – LiveData to stop to listen Type parameters: &lt;S&gt; – the type of data hold by source LiveData" />
      <item value="Calls the specified function block with the given receiver as its receiver and returns its result. For detailed usage information see the documentation for scope functions ." />
      <item value="route" />
      <item value="wait Delay" />
      <item value="Retrieve the current back stack. Returns: The current back stack." />
      <item value="Returns true if the receiver is currently processing an ordered broadcast." />
      <item value="shipment Busy" />
      <item value="Return true if Bluetooth is currently enabled and ready for use. Equivalent to: getBluetoothState() == STATE_ON Returns: true if the local adapter is turned on" />
      <item value="handle" />
      <item value="Simple Result" />
      <item value="By overriding invoke, we allow use cases to be called as &quot;invoking&quot;" />
      <item value="Sends the specified element to this channel, suspending the caller while the buffer of this channel is full or if it does not exist, or throws an exception if the channel is closed for send (see close for details). Closing a channel after this function has suspended does not cause this suspended send invocation to abort, because closing a channel is conceptually like sending a special &quot;close token&quot; over this channel. All elements sent over the channel are delivered in first-in first-out order. The sent element will be delivered to receivers before the close token. This suspending function is cancellable. If the Job of the current coroutine is cancelled or completed while this function is suspended, this function immediately resumes with a CancellationException. There is a prompt cancellation guarantee. If the job was cancelled while this function was suspended, it will not resume successfully. The send call can send the element to the channel, but then throw CancellationException, thus an exception should not be treated as a failure to deliver the element. See &quot;Undelivered elements&quot; section in Channel documentation for details on handling undelivered elements. Note that this function does not check for cancellation when it is not suspended. Use yield or CoroutineScope.isActive to periodically check for cancellation in tight loops if needed. This function can be used in select invocations with the onSend clause. Use trySend to try sending to this channel without waiting." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="ENGLISH" value="1224" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1224" />
        <entry key="FILIPINO" value="1" />
        <entry key="FINNISH" value="1" />
        <entry key="DUTCH" value="2" />
        <entry key="GALICIAN" value="1" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1656306537062" />
  </component>
</application>